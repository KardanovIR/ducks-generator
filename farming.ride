
{-# STDLIB_VERSION 4 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let eggsAssetId = base58'53bLXGQhnMxAoiWnza2SJQRp7hNQZVHnyrRziLmwdVjb'
let perchPrice = 100
let scale = 10000

let incubatorAddress = base58'3P6TwNU39Ykkbeqhn5TE4a2736xsA1vXemM'
let breederAddress = base58'3P9REuLBnYBafDqtEu6hfzs2Rv2haSU158y'

let GENS = ["A", "B", "C", "D", "E", "F", "G"]

func getRewardPerBlock() = {
  684 # 0.0684 EGGs per block
}

func tryGetInteger(key: String) = {
    match getInteger(this, key) {
        case b:Int => b
        case _ => 0
    }
}

func tryGetString(key: String) = {
    match getString(this, key) {
        case a:String => a
        case _ => ""
    }
}

func isSymbolA(accumulated: Int, sym: String) = { if (sym == "A") then {accumulated+1} else {accumulated+0} }
func isSymbolB(accumulated: Int, sym: String) = { if (sym == "B") then {accumulated+1} else {accumulated+0} }
func isSymbolC(accumulated: Int, sym: String) = { if (sym == "C") then {accumulated+1} else {accumulated+0} }
func isSymbolD(accumulated: Int, sym: String) = { if (sym == "D") then {accumulated+1} else {accumulated+0} }
func isSymbolE(accumulated: Int, sym: String) = { if (sym == "E") then {accumulated+1} else {accumulated+0} }
func isSymbolF(accumulated: Int, sym: String) = { if (sym == "F") then {accumulated+1} else {accumulated+0} }
func isSymbolG(accumulated: Int, sym: String) = { if (sym == "G") then {accumulated+1} else {accumulated+0} }
func isSymbolH(accumulated: Int, sym: String) = { if (sym == "H") then {accumulated+1} else {accumulated+0} }

func getAmountOrClear(amount: String) = {
  if (amount.contains("0")) then {""} else {amount}
}

func getGen(assetName: String) = {
  # getGen("DUCK-ABCDDCBA-GY") -> 2A2B2C2D-G
  let genotype = assetName.drop(5).dropRight(3).split("")
  getAmountOrClear(toString(FOLD<8>(genotype, 0, isSymbolA)) + "A") + getAmountOrClear(toString(FOLD<8>(genotype, 0, isSymbolB)) + "B") + getAmountOrClear(toString(FOLD<8>(genotype, 0, isSymbolC)) + "C") +
  getAmountOrClear(toString(FOLD<8>(genotype, 0, isSymbolD)) + "D") + getAmountOrClear(toString(FOLD<8>(genotype, 0, isSymbolE)) + "E") + getAmountOrClear(toString(FOLD<8>(genotype, 0, isSymbolF)) + "F") +
  getAmountOrClear(toString(FOLD<8>(genotype, 0, isSymbolG)) + "G") + getAmountOrClear(toString(FOLD<8>(genotype, 0, isSymbolH)) + "H")
}

func getAssetOrigin(generation: String) = {
  if (generation == "G") then {incubatorAddress} else {breederAddress}
}

func getAssetRarity(genotype: String, generation: String) = {
  let quantity = getIntegerValue(Address(getAssetOrigin(generation)), "stats_"+genotype+"_quantity")
  pow(100 / quantity, 2, 5, 1, 2, HALFDOWN)
}

func getAssetFarmingPower(assetId: ByteVector) = {
  let assetName = assetInfo(assetId).value().name
  let generation = assetName.takeRight(2).take(1)
  let gen = getGen(assetName) + "-" + generation
  (gen, getAssetRarity(gen, generation))
}

func getLastKnownAssetFarmingPower(address: String, assetId: String) = {
  tryGetInteger("address_"+address+"_asset_"+assetId+"_farmingPower")
}

func getAssetsByGen(gen: String) = {
  let s = tryGetString("assets_"+gen)
  if (s == "") then {[]} else {s.split(",")}
}

func calcInterest(previousInterest: Int, previousInterestHeight: Int, totalFarmingPower: Int) = {
  # interest = amount of EGGlets you would earn if staked 1 percent of farming power since the very first block of farming
  previousInterest + scale * getRewardPerBlock() * (height-previousInterestHeight) / totalFarmingPower
}

func getCurrentInterest() = {
  if (tryGetInteger("total_farmingPower") > 0) then {
    let previousInterest = tryGetInteger("total_lastCheckInterest")
    let previousInterestHeight = tryGetInteger("total_lastCheckInterestHeight")
    let totalFarmingPower = tryGetInteger("total_farmingPower")

    calcInterest(previousInterest, previousInterestHeight, totalFarmingPower)
  } else if (tryGetInteger("total_startHeight") <= height) then { 0 } else { throw("farming is not launched, yet") }
}


func calcAssetRewardDelta(address: String, assetId: String, assetFarmingPower: Int) = {
  let lastCheckUserInterest = tryGetInteger("address_"+address+"_asset_"+assetId+"_lastCheckInterest")
  let currentInterest = getCurrentInterest()

  assetFarmingPower * (currentInterest - lastCheckUserInterest)
}


func addAssetIdToGenEntry(assetId: String, assetGen: String) = {
  let currentValue = tryGetString("assets_"+assetGen+"_locked")
  if (currentValue == "") then {assetId} else {currentValue+","+assetId}
}


func getCheckDataChanges(address: String, assetId: ByteVector, rewardDelta: Int, assetFarmingPowerDelta: Int) = {
  # called when staking/unstaking NFT or claiming reward
  let asset = assetId.toBase58String()
  [
    IntegerEntry("total_farmingPower", tryGetInteger("total_farmingPower") + assetFarmingPowerDelta),
    IntegerEntry("total_lastCheckInterest", getCurrentInterest()),
    IntegerEntry("total_lastCheckInterestHeight", height),
    IntegerEntry("address_"+address+"_asset_"+asset+"_farmingPower", tryGetInteger("address_"+address+"_asset_"+asset+"_farmingPower") + assetFarmingPowerDelta),
    IntegerEntry("address_"+address+"_asset_"+asset+"_lastCheckInterest", getCurrentInterest()),

    IntegerEntry("address_"+address+"_asset_"+asset+"_lastCheckFarmedAmount", tryGetInteger("address_"+address+"_asset_"+asset+"_lastCheckFarmedAmount") + rewardDelta)
  ]
}

func claimResult(address: String, asset: String, farmedAmount: Int) = {
  [
    IntegerEntry("address_"+address+"_asset_"+asset+"_withdrawnAmount", farmedAmount),
    ScriptTransfer(Address(address.fromBase58String()), farmedAmount, eggsAssetId)
  ]
}

@Callable(i)
func init() = {
  if (i.caller != this) then { throw("admin only") } else {
    [ IntegerEntry("total_startHeight", height) ]
  }
}

@Callable(i)
func buyPerch(color: String) = {
  if (["B", "R", "G", "Y"].indexOf(color).value() < 0) then {
    throw("you need to set color properly")
  } else {
    let firstPayment = i.payments[0].value()
    if (firstPayment.assetId != eggsAssetId) then throw("You can attach only EGG tokens with the following asset id: " + eggsAssetId.toBase58String())
    else if (firstPayment.amount != perchPrice) then throw("To buy a perch you currently need the following amount of EGGlets: " + perchPrice.toString())
    else {
      let perchAmountKey = "address_" + i.caller.toString() + "_perchesAvailable_" + color
      let perchAmount = tryGetInteger(perchAmountKey)
      [
        IntegerEntry(perchAmountKey, perchAmount + 1)
      ]
    }
  }
}

@Callable(i)
func stakeNFT() = {
  let assetId = i.payments[0].value().assetId.value()
  let address = i.caller.toString()

  let color = assetInfo(assetId).value().name.takeRight(1)
  let availablePerches = tryGetInteger("address_"+i.caller.toString()+"_perchesAvailable_"+color)

  if (availablePerches <= 0) then {
    throw("no perches available for the color " + color)
  } else {
    let (assetGen, assetFarmingPower) = getAssetFarmingPower(assetId)
    let assetRewardDelta = calcAssetRewardDelta(address, assetId.toBase58String(), assetFarmingPower)

    getCheckDataChanges(address, assetId, assetRewardDelta, assetFarmingPower) ++ [
      IntegerEntry("address_"+i.caller.toString()+"_perchesAvailable_"+color, availablePerches - 1)
    ]
  }  
}

@Callable(i)
func unstakeNFT(asset: String) = {
  let assetId = asset.fromBase58String()
  let address = i.caller.toString()

  let assetFarmingPower = getLastKnownAssetFarmingPower(address, asset)
  let assetRewardDelta = calcAssetRewardDelta(address, asset, assetFarmingPower)

  let farmedAmount = assetRewardDelta + tryGetInteger("address_"+address+"_asset_"+asset+"_lastCheckFarmedAmount")
  let withdrawnAmount = tryGetInteger("address_"+address+"_asset_"+asset+"_withdrawnAmount")

  let reward = (farmedAmount - withdrawnAmount) / (scale * 100)

  let color = assetInfo(assetId).value().name.takeRight(1)
  let result = getCheckDataChanges(address, assetId, assetRewardDelta, -assetFarmingPower)

  result ++ claimResult(address, asset, reward) ++ [
    IntegerEntry("address_"+i.caller.toString()+"_perchesAvailable_"+color, tryGetInteger("address_"+i.caller.toString()+"_perchesAvailable_"+color) + 1),
    ScriptTransfer(i.caller, 1, assetId)
  ]
}

# @Callable(i)
# func checkNFT(asset: String) = {
#   let assetRewardDelta = calcAssetRewardDelta(i.caller.toString(), asset)
#   getCheckDataChanges(i.caller.toString(), asset.fromBase58String(), assetRewardDelta, 0, "")
# }

@Callable(i)
func claimReward(asset: String) = {
  let address = i.caller.toString()
  let assetId = asset.fromBase58String()

  let (assetGen, assetFarmingPower) = getAssetFarmingPower(assetId)
  let rewardDelta = calcAssetRewardDelta(address, asset, assetFarmingPower)
  let farmedAmount = rewardDelta + tryGetInteger("address_"+address+"_asset_"+asset+"_lastCheckFarmedAmount")
  let withdrawnAmount = tryGetInteger("address_"+address+"_asset_"+asset+"_withdrawnAmount")

  let reward = (farmedAmount - withdrawnAmount) / (scale * 100)

  if (reward <= 0) then {
    throw("you have no EGGs to withdraw")
  } else {
    claimResult(asset, address, farmedAmount)
  }
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
        
